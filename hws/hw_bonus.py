"""
<<<<<<< HEAD
💎 Exercise-1: Memoized Fibonacci
Implement a memoized version of the Fibonacci sequence. The function "memoized_fibonacci(n: int) -> int" should return the nth number in the Fibonacci sequence, and it should use a cache to improve performance on subsequent calls.

Example:
memoized_fibonacci(10) -> 55
"""

def memoized_fibonacci(n: int) -> int:
    pass

"""
💎 Exercise-2: Currying Function
Write a function "curry(func, *args)" that implements currying. The function should return a new function that when called will return the result of applying the input function to the provided arguments, followed by the new arguments.

Example:
def add_three_numbers(a, b, c):
    return a + b + c
add_five_and_six = curry(add_three_numbers, 5, 6)
add_five_and_six(7) -> 18
"""

def curry(func, *args):
    pass

"""
💎 Exercise-3: Implement zip() using map() and lambda
Write a function "my_zip(*iterables)" that takes in multiple iterables and returns an iterator that aggregates elements from each of the iterables.

Example:
my_zip([1, 2, 3], [4, 5, 6]) -> [(1, 4), (2, 5), (3, 6)]
"""

def my_zip(*iterables):
    pass

"""
💎 Exercise-4: Caching Decorator
Write a decorator "caching_decorator(func)" that caches the results of the function it decorates.

Example:
@caching_decorator
def expensive_function(x, y):
    # Simulate an expensive function by sleeping
    import time
    time.sleep(5)
    return x + y
"""

def caching_decorator(func):
    pass

"""
💎 Exercise-5: Recursive Flattening
Write a function "recursive_flatten(input_list: list) -> list" that takes a nested list and flattens it.

Example:
recursive_flatten([1, [2, [3, 4], 5]]) -> [1, 2, 3, 4, 5]
"""

def recursive_flatten(input_list: list) -> list:
    pass

"""
💎 Exercise-6: Decorator for Checking Function Arguments
Write a decorator "check_args(*arg_types)" that checks the types of the arguments passed to the function it decorates.

Example:
@check_args(int, int)
def add(a, b):
    return a + b
"""

def check_args(*arg_types):
=======
💎 Exercise-1: Two Sum
Write a function "two_sum(nums: list, target: int) -> tuple" that takes a list of integers
and a target integer. It should return a tuple of two indices whose elements add up to the target.
Assume that each input would have exactly one solution, and you may not use the same element twice.

Example:
two_sum([2, 7, 11, 15], 9) -> (0, 1)
"""

def two_sum(nums: list, target: int) -> tuple:
    pass

"""
💎 Exercise-2: Isomorphic Strings
Write a function "is_isomorphic(s: str, t: str) -> bool" that takes two strings s and t
and determines if they are isomorphic. Two strings s and t are isomorphic if the characters
in s can be replaced to get t, and all characters in s map to exactly one character in t and vice versa.

Example:
is_isomorphic('egg', 'add') -> True
"""

def is_isomorphic(s: str, t: str) -> bool:
    pass

"""
💎 Exercise-3: Check Alien Dictionary
Write a function "is_alien_sorted(words: list, order: str) -> bool" that checks if words
are sorted lexicographicaly according to a new character order provided in the string order.

Example:
is_alien_sorted(["hello","leetcode"], "hlabcdefgijkmnopqrstuvwxyz") -> True
"""

def is_alien_sorted(words: list, order: str) -> bool:
    pass

"""
💎 Exercise-4: Longest Substring Without Repeating Characters
Write a function "length_of_longest_substring(s: str) -> int" that takes a string s,
and returns the length of the longest substring without repeating characters.

Example:
length_of_longest_substring('abcabcbb') -> 3
"""

def length_of_longest_substring(s: str) -> int:
    pass

"""
💎 Exercise-5: Group Shifted Strings
Write a function "group_shifted(strings: list) -> list" that takes a
list of lowercase strings and groups all strings that are generated by shifting some letters
of another string circularly. Return a list of groups, each group is a list of strings.
Groups and strings within a group can be in any order.

Example:
group_shifted(["abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"]) -> [["abc","bcd"],["acef"],["xyz"],["az","ba"],["a","z"]]
"""

def group_shifted(strings: list) -> list:
>>>>>>> main
    pass